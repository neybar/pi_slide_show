# Architecture Decisions

This document captures the architectural intent and key decisions for the pi_slide_show project. Reference this when making implementation choices.

## Core Purpose

**A digital picture frame that surfaces forgotten memories by displaying thematically cohesive photo batches from random leaf folders.**

The goal is nostalgia and surprise—showing photos you forgot you had, organized by the events and moments they represent.

---

## Architectural Principles

### 1. Backend is Client-Agnostic

The Node.js backend serves a simple HTTP API. Multiple frontend clients can consume it:

```
                    ┌─────────────────┐
                    │   NAS (Photos)  │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │  Backend Server │  ← Single instance, stable API
                    │   (Node.js)     │
                    └────────┬────────┘
                             │
           ┌─────────────────┼─────────────────┐
           │                 │                 │
    ┌──────▼──────┐   ┌──────▼──────┐   ┌──────▼──────┐
    │  Pi + TV    │   │  Pi + TV    │   │  AppleTV    │
    │  (browser)  │   │  (browser)  │   │  (native)   │
    └─────────────┘   └─────────────┘   └─────────────┘
```

**Implication:** API design should not assume browser-specific features. Keep responses simple (JSON with paths and metadata).

### 2. Filesystem is the Interface

The photo library is accessed via filesystem (local or NFS-mounted). The NAS vendor (Synology, FreeNAS, Unifi) can change; the folder structure will not.

**Stable:**
- Folder hierarchy and naming conventions
- Photo file organization
- Year/Event folder structure

**Unstable:**
- Thumbnail generation method
- Thumbnail storage location
- Vendor-specific metadata

### 3. Folder Structure is Sacred

Photos are organized by the user in a deliberate hierarchy:

```
Photo Library/
├── 2019/                              ← Parent (no photos)
│   ├── January/                       ← Leaf (photos here)
│   ├── July - Hawaii Trip - Day 1/    ← Leaf (photos here)
│   ├── July - Hawaii Trip - Day 2/    ← Leaf (photos here)
│   └── December - Christmas/          ← Leaf (photos here)
├── 2020/                              ← Parent (no photos)
│   └── ...
```

**Rules:**
- Only **leaf folders** contain photos
- Parent folders are organizational containers only
- Each leaf folder represents a **theme** (event, trip day, month)
- Random selection happens at the **folder level**, not photo level
- A displayed batch should be cohesive—all from the same leaf folder

### 4. Thumbnails are Vendor-Dependent

Currently using Synology's auto-generated thumbnails:
```
@eaDir/SYNOPHOTO_THUMB_XL.jpg
@eaDir/SYNOPHOTO_THUMB_M.jpg
```

**Future consideration:** If NAS vendor changes, thumbnails may need to be:
- Generated by the app itself (ImageMagick, sharp)
- Located via a pluggable strategy pattern
- Cached in app-controlled location

This is a known abstraction that may need extraction later.

### 5. Stateless Frontend

The frontend is a "set and forget" kiosk display:

- No user interaction (no pause, skip, favorite)
- No state persistence
- No control plane or remote control
- If it crashes, reload and start fresh with new random batch

**Implication:** No need for websockets, session management, or state synchronization between clients.

**Frontend Module Organization:**

The frontend logic is organized into specialized ES modules for maintainability and testability:

- `www/js/config.mjs` - Shared configuration constants (animation timing, layout probabilities, thresholds)
- `www/js/photo-store.mjs` - Photo selection and layout algorithms (orientation matching, panorama detection, space management, stacked landscapes)
- `www/js/prefetch.mjs` - Album pre-fetch pure functions (memory guards, validation, timing)
- `www/js/utils.mjs` - Shared utilities (thumbnail path building, quality levels)
- `www/js/main.js` - Main application logic (photo swapping, animations, album transitions)

This modular structure allows unit testing of pure functions (photo selection, layout algorithms, prefetch logic) independently of DOM manipulation and jQuery dependencies.

### 5.1 Recovery and Resilience

**Animation Watchdog System:** `www/js/main.js` includes a background watchdog that monitors live cells for failures and stuck states, preventing the empty cell issue that can occur when animations are interrupted or fail to clean up properly.

The watchdog (running every 3 seconds via `startAnimationWatchdog()`) detects and recovers from two failure modes:

1. **Failed Image Loads** - When an image fails to load (`onerror` event):
   - Marked with `needs-recovery` timestamp via `.one()` handler
   - Detected after 500ms grace period (allows time for browser retry)
   - Recovered by swapping the photo with a new one from the store
   - Deferred via `_.delay()` to avoid race conditions during ongoing animations

2. **Stuck-Invisible Cells** - When cells remain invisible/opaque after animations complete:
   - Tracked with `stuck-since` timestamp in watchdog loop
   - Threshold calculated from animation config: `maxAnimationTime + WATCHDOG_STUCK_GRACE_PERIOD_MS`
   - Recovered by clearing inline CSS styles that hide the cell
   - Respects configuration changes without code modification

**Memory Management** - Prevents memory leaks through:
- `.one()` error handler (fires once, no handler accumulation)
- Interval cleanup in `clearAllPendingTimers()` on page transitions
- Orphaned DOM element return to `photo_store` when not used
- DOM query safety checks (skip detached elements in watchdog loop)

**Configuration** - All watchdog timing is configurable via `www/js/config.mjs`:
- `WATCHDOG_INTERVAL_MS` - Scan frequency
- `WATCHDOG_STUCK_GRACE_PERIOD_MS` - Grace period before marking stuck
- `WATCHDOG_LOAD_ERROR_DELAY_MS` - Delay before recovering failed loads
- `WATCHDOG_SWAP_DEFER_MS` - Deferral for swap queueing

### 6. Performance = No Black Screen

The primary performance metric is **perceived continuity**. Users should never see a black/empty screen between album transitions.

**Strategy:** Pre-fetch the next album while the current one displays.

```
Timeline (goal):
[Album A displays]──────────────────[Album B displays]──────────
           ↑                               ↑
    Fetch B in background           Fetch C in background
```

**Not the goal:** Progressive image quality (M→XL) is less valuable than seamless transitions.

**Thumbnail sizing:** Collage display doesn't need full-resolution photos. Thumbnails (XL quality) are sufficient even for large displays. As phone cameras produce larger files, the app should remain snappy by using appropriately-sized thumbnails.

---

## Display Characteristics

| Attribute | Current | Future Possibility |
|-----------|---------|-------------------|
| Screen size | 22" | Larger TV, 4K |
| Resolution | 1080p | 4K |
| Client | Pi + Chromium | AppleTV app |
| Instances | 1 | Multiple frames |

**Design for:** Collage display where individual photos don't need full resolution. Optimize for batch loading speed over individual image quality.

---

## What This Project Is NOT

- **Not a photo management app** - Photos are managed externally (Synology Photos, filesystem)
- **Not interactive** - No browsing, searching, or user input
- **Not a photo editor** - No cropping, filtering, or modifications
- **Not a backup solution** - Read-only access to existing library
- **Not a social app** - No sharing, comments, or multi-user features

---

## API Contract

The backend API should remain stable for multiple client types:

| Endpoint | Purpose | Response |
|----------|---------|----------|
| `GET /` | Serve the slideshow viewer | HTML |
| `GET /album/:count` | Get random photos from a leaf folder | `{count, images: [{file, Orientation}]}` |
| `GET /album/fixture/:year` | Get fixed photos for testing (disabled in prod) | `{count, images: [...]}` |
| `GET /photos/*` | Serve photo/thumbnail files | Binary image data |

**Future considerations:**
- Thumbnail size parameter (`?size=M\|XL\|original`)
- Metadata inclusion (`?include=date,folder`)
- Client capability negotiation

---

## Related Documentation

- **[Visual Layout Algorithm](docs/visual-algorithm.md)** - Detailed documentation of the photo layout system, cell configurations, swap cycles, and gravity-based animation

---

## Open Questions / Future Decisions

1. **Thumbnail abstraction** - When/if to extract thumbnail strategy from Synology-specific code
2. **~~Pre-fetch implementation~~** - **IMPLEMENTED** (Frontend-based): Pre-fetch begins 1 minute before transition (configurable via `PREFETCH_LEAD_TIME`). Uses AbortController for cancellation, memory guard to prevent OOM (`PREFETCH_MEMORY_THRESHOLD_MB`), and periodic full reload for memory hygiene (`FORCE_RELOAD_INTERVAL`). Album transition uses deliberate fade-out → fade-in sequence to create a clear "chapter break" between albums (no photo mixing). Falls back to page reload if prefetch fails or memory is insufficient.
3. **Multi-client coordination** - Should multiple displays avoid showing the same album simultaneously?
4. **Album weighting** - Should newer folders have higher selection probability, or pure random?
