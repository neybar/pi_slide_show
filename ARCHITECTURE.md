# Architecture Decisions

This document captures the architectural intent and key decisions for the pi_slide_show project. Reference this when making implementation choices.

## Core Purpose

**A digital picture frame that surfaces forgotten memories by displaying thematically cohesive photo batches from random leaf folders.**

The goal is nostalgia and surprise—showing photos you forgot you had, organized by the events and moments they represent.

---

## Architectural Principles

### 1. Backend is Client-Agnostic

The Node.js backend serves a simple HTTP API. Multiple frontend clients can consume it:

```
                    ┌─────────────────┐
                    │   NAS (Photos)  │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │  Backend Server │  ← Single instance, stable API
                    │   (Node.js)     │
                    └────────┬────────┘
                             │
           ┌─────────────────┼─────────────────┐
           │                 │                 │
    ┌──────▼──────┐   ┌──────▼──────┐   ┌──────▼──────┐
    │  Pi + TV    │   │  Pi + TV    │   │  AppleTV    │
    │  (browser)  │   │  (browser)  │   │  (native)   │
    └─────────────┘   └─────────────┘   └─────────────┘
```

**Implication:** API design should not assume browser-specific features. Keep responses simple (JSON with paths and metadata).

### 2. Filesystem is the Interface

The photo library is accessed via filesystem (local or NFS-mounted). The NAS vendor (Synology, FreeNAS, Unifi) can change; the folder structure will not.

**Stable:**
- Folder hierarchy and naming conventions
- Photo file organization
- Year/Event folder structure

**Unstable:**
- Thumbnail generation method
- Thumbnail storage location
- Vendor-specific metadata

### 3. Folder Structure is Sacred

Photos are organized by the user in a deliberate hierarchy:

```
Photo Library/
├── 2019/                              ← Parent (no photos)
│   ├── January/                       ← Leaf (photos here)
│   ├── July - Hawaii Trip - Day 1/    ← Leaf (photos here)
│   ├── July - Hawaii Trip - Day 2/    ← Leaf (photos here)
│   └── December - Christmas/          ← Leaf (photos here)
├── 2020/                              ← Parent (no photos)
│   └── ...
```

**Rules:**
- Only **leaf folders** contain photos
- Parent folders are organizational containers only
- Each leaf folder represents a **theme** (event, trip day, month)
- Random selection happens at the **folder level**, not photo level
- A displayed batch should be cohesive—all from the same leaf folder

### 4. Thumbnails are Vendor-Dependent

Currently using Synology's auto-generated thumbnails:
```
@eaDir/SYNOPHOTO_THUMB_XL.jpg
@eaDir/SYNOPHOTO_THUMB_M.jpg
```

**Future consideration:** If NAS vendor changes, thumbnails may need to be:
- Generated by the app itself (ImageMagick, sharp)
- Located via a pluggable strategy pattern
- Cached in app-controlled location

This is a known abstraction that may need extraction later.

### 5. Stateless Frontend

The frontend is a "set and forget" kiosk display:

- No user interaction (no pause, skip, favorite)
- No state persistence
- No control plane or remote control
- If it crashes, reload and start fresh with new random batch

**Implication:** No need for websockets, session management, or state synchronization between clients.

### 6. Performance = No Black Screen

The primary performance metric is **perceived continuity**. Users should never see a black/empty screen between album transitions.

**Strategy:** Pre-fetch the next album while the current one displays.

```
Timeline (goal):
[Album A displays]──────────────────[Album B displays]──────────
           ↑                               ↑
    Fetch B in background           Fetch C in background
```

**Not the goal:** Progressive image quality (M→XL) is less valuable than seamless transitions.

**Thumbnail sizing:** Collage display doesn't need full-resolution photos. Thumbnails (XL quality) are sufficient even for large displays. As phone cameras produce larger files, the app should remain snappy by using appropriately-sized thumbnails.

---

## Display Characteristics

| Attribute | Current | Future Possibility |
|-----------|---------|-------------------|
| Screen size | 22" | Larger TV, 4K |
| Resolution | 1080p | 4K |
| Client | Pi + Chromium | AppleTV app |
| Instances | 1 | Multiple frames |

**Design for:** Collage display where individual photos don't need full resolution. Optimize for batch loading speed over individual image quality.

---

## What This Project Is NOT

- **Not a photo management app** - Photos are managed externally (Synology Photos, filesystem)
- **Not interactive** - No browsing, searching, or user input
- **Not a photo editor** - No cropping, filtering, or modifications
- **Not a backup solution** - Read-only access to existing library
- **Not a social app** - No sharing, comments, or multi-user features

---

## API Contract

The backend API should remain stable for multiple client types:

| Endpoint | Purpose | Response |
|----------|---------|----------|
| `GET /album/:count` | Get random photos from a leaf folder | `{count, images: [{file, orientation}]}` |
| `GET /photos/*` | Serve photo/thumbnail files | Binary image data |

**Future considerations:**
- Thumbnail size parameter (`?size=M\|XL\|original`)
- Metadata inclusion (`?include=date,folder`)
- Client capability negotiation

---

## Open Questions / Future Decisions

1. **Thumbnail abstraction** - When/if to extract thumbnail strategy from Synology-specific code
2. **Pre-fetch implementation** - Frontend vs backend responsibility for next-album preparation
3. **Multi-client coordination** - Should multiple displays avoid showing the same album simultaneously?
4. **Album weighting** - Should newer folders have higher selection probability, or pure random?
